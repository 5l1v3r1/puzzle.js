// A Phase2Cube represents the state of a cube that is important to the phase-2
// solver.
function Phase2Cube() {
  this.cornerPerm = 0;
  this.edgePerm = 0;
  this.slicePerm = 0;
}

// move applies a phase-2 move (a number in the range [0, 10)) to the cube given
// a pre-computed Phase2Moves table.
Phase2Cube.prototype.move = function(m, moves) {
  this.cornerPerm = moves.cornerMoves[this.cornerPerm*10 + m];
  this.edgePerm = moves.edgeMoves[this.edgePerm*10 + m];
  this.slicePerm = moves.sliceMoves[this.slicePerm*10 + m];
};

// solved returns true if the Phase2Cube is solved.
Phase2Cube.prototype.solved = function() {
  return p.cornerPerm === 0 && p.edgePerm === 0 && p.slicePerm === 0;
};

// Phase2Moves stores a set of tables which can be used to apply moves to a
// phase-2 state.
function Phase2Moves() {
  this.cornerMoves = new Uint16Array(403200);
  this.edgeMoves = new Uint16Array(403200);
  this.sliceMoves = new Uint16Array(240);
  
  var perm8 = perms.allPerms(8);
  this._generateCornerMoves(perm8);
  this._generateEdgeMoves(perm8);
  this._generateSliceMoves();
}

Phase2Moves.prototype._generateCornerMoves = function(perm8) {
  for (var i = 0; i < 403200; ++i) {
    this.cornerMoves[i] = 0xffff;
  }
  
  // Apply every move to every corner state.
  for (var state = 0; state < 40320; ++state) {
    var perm = perm8[state];
    
    // Loop through all 10 moves and apply them.
    for (var m = 0; m < 10; ++m) {
      if (this.cornerMoves[state*10 + m] !== 0xffff) {
        continue;
      }
      
      // Record the end state of this move.
      var endState = moveYCornerPerm(perm, m);
      this.cornerMoves[state*10 + m] = endState;
      
      // Set the inverse of this state.
      this.cornerMoves[endState*10 + p2MoveInverse(m)] = state;
    }
  }
};

Phase2Moves.prototype._generateEdgeMoves = function(perm8) {
  for (var i = 0; i < 403200; ++i) {
    this.edgeMoves[i] = 0xffff;
  }
  
  // Apply every move to every edge state.
  for (var state = 0; state < 40320; ++state) {
    var perm = perm8[state];
    
    // Apply all 10 moves to the cube.
    for (var m = 0; m < 10; ++m) {
      if (this.edgeMoves[state*10 + m] !== 0xffff) {
        continue;
      }
      
      var endState = moveUDEdgePerm(perm, m);
      this.edgeMoves[state*10 + m] = endState;
      
      // Set the inverse of this state.
      this.edgeMoves[endState*10 + p2MoveInverse(m)] = state;
    }
  }
};

Phase2Moves.prototype._generateSliceMoves = function() {
  // NOTE: I don't bother with any optimizations here because it's only 24 cases
  // as opposed to 40320 for the other types of state.
  var perm4 = perms.allPerms(4);
  for (var i = 0; i < 24; ++i) {
    var perm = perm4[i];
    
    // Apply all 10 moves to the state.
    for (var m = 0; m < 10; ++m) {
      var endState = moveESlicePerm(perm, m);
      this.sliceMoves[i*10 + m] = endState;
    }
  }
};

function moveESlicePerm(perm, move) {
  var p = perm.slice();
  var temp;
  switch (move) {
  case 0:
    temp = p[0];
    p[0] = p[1];
    p[1] = temp;
    break;
  case 1:
    temp = p[2];
    p[2] = p[3];
    p[3] = temp;
    break;
  case 2:
    temp = p[0];
    p[0] = p[2];
    p[2] = temp;
    break;
  case 3:
    temp = p[1];
    p[1] = p[3];
    p[3] = temp;
  default:
    break;
  }
  return perms.encodeDestructablePerm(p);
}

function moveUDEdgePerm(perm, move) {
  // NOTE: this code was generated by translating Go code to JavaScript.
  var p = perm.slice();
  var temp;
  switch (move) {
  case 0:
    temp = p[2];
    p[2] = p[6];
    p[6] = temp;
    break;
  case 1:
    temp = p[0];
    p[0] = p[4];
    p[4] = temp;
    break;
  case 2:
    temp = p[1];
    p[1] = p[5];
    p[5] = temp;
    break;
  case 3:
    temp = p[3];
    p[3] = p[7];
    p[7] = temp;
    break;
  case 4:
    temp = p[3];
    p[3] = p[2];
    p[2] = p[1];
    p[1] = p[0];
    p[0] = temp;
    break;
  case 5:
    temp = p[3];
    p[3] = p[0];
    p[0] = p[1];
    p[1] = p[2];
    p[2] = temp;
    break;
  case 6:
    temp = p[0];
    p[0] = p[2];
    p[2] = temp;
    temp = p[1];
    p[1] = p[3];
    p[3] = temp;
    break;
  case 7:
    temp = p[7];
    p[7] = p[4];
    p[4] = p[5];
    p[5] = p[6];
    p[6] = temp;
    break;
  case 8:
    temp = p[7];
    p[7] = p[6];
    p[6] = p[5];
    p[5] = p[4];
    p[4] = temp;
    break;
  case 9:
    temp = p[4];
    p[4] = p[6];
    p[6] = temp;
    temp = p[5];
    p[5] = p[7];
    p[7] = temp;
    break;
  default:
    break;
  }
  return perms.encodeDestructablePerm(p);
}

function moveYCornerPerm(perm, move) {
  // NOTE: this code was generated by translating Go code to JavaScript.
  var p = perm.slice();
  var temp;
  switch (move) {
  case 0:
    temp = p[5];
    p[5] = p[6];
    p[6] = temp;
    temp = p[4];
    p[4] = p[7];
    p[7] = temp;
    break;
  case 1:
    temp = p[1];
    p[1] = p[2];
    p[2] = temp;
    temp = p[0];
    p[0] = p[3];
    p[3] = temp;
    break;
  case 2:
    temp = p[1];
    p[1] = p[7];
    p[7] = temp;
    temp = p[3];
    p[3] = p[5];
    p[5] = temp;
    break;
  case 3:
    temp = p[0];
    p[0] = p[6];
    p[6] = temp;
    temp = p[2];
    p[2] = p[4];
    p[4] = temp;
    break;
  case 4:
    temp = p[6];
    p[6] = p[7];
    p[7] = p[3];
    p[3] = p[2];
    p[2] = temp;
    break;
  case 5:
    temp = p[6];
    p[6] = p[2];
    p[2] = p[3];
    p[3] = p[7];
    p[7] = temp;
    break;
  case 6:
    temp = p[2];
    p[2] = p[7];
    p[7] = temp;
    temp = p[3];
    p[3] = p[6];
    p[6] = temp;
    break;
  case 7:
    temp = p[0];
    p[0] = p[1];
    p[1] = p[5];
    p[5] = p[4];
    p[4] = temp;
    break;
  case 8:
    temp = p[0];
    p[0] = p[4];
    p[4] = p[5];
    p[5] = p[1];
    p[1] = temp;
    break;
  case 9:
    temp = p[0];
    p[0] = p[5];
    p[5] = temp;
    temp = p[1];
    p[1] = p[4];
    p[4] = temp;
    break;
  default:
    break;
  }
  return perms.encodeDestructablePerm(p);
}

// p2MoveFace returns the face of a phase-2 move.
function p2MoveFace(m) {
  return [2, 3, 4, 5, 0, 0, 0, 1, 1, 1][m] + 1;
}

// p2MoveInverse finds the inverse of a phase-2 move.
function p2MoveInverse(m) {
  return [0, 1, 2, 3, 5, 4, 6, 8, 7, 9][m];
}

// p2MoveMove returns the Move for a phase-2 move.
function p2MoveMove(m, axis) {
  var num = [
    [14, 15, 12, 13, 5, 11, 17, 4, 10, 16],
		[14, 15, 16, 17, 0, 6, 12, 1, 7, 13],
		[13, 12, 16, 17, 2, 8, 14, 3, 9, 15]
  ][axis][m];
}

exports.Phase2Cube = Phase2Cube;
exports.Phase2Moves = Phase2Moves;
exports.p2MoveFace = p2MoveFace;
exports.p2MoveInverse = p2MoveInverse;
exports.p2MoveMove = p2MoveMove;
