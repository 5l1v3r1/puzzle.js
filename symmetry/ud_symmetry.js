// There are 16 symmetries of the cube which preserve the UD axis. These
// symmetries can be generated by performing cube rotations around the y axis,
// flips across the LR axis, and flips across the UD axis. The LR flip could be
// substituted for an FB flip; I chose LR arbitrarily.
//
// Since there are 16 symmetries, I represent symmetries as 4 bit numbers. The
// lower 2 bits store the number of y rotations. The third bit is set for an LR
// flip, and the fourth bit for a UD flip. If there is a y rotation, an LR flip,
// and a UD flip, the y rotation is performed first, the LR flip second, and the
// UD flip third. So, symmetry 15 represents UDflip*LRflip*y'. It can also be
// noted that the UD flip commutes with the LR flip and the y rotation.

// udSymmetryProducts[a*16 + b] gives the symmetry a*b.
var udSymmetryProducts = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  1, 2, 3, 0, 7, 4, 5, 6, 9, 10, 11, 8, 15, 12, 13, 14,
  2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13,
  3, 0, 1, 2, 5, 6, 7, 4, 11, 8, 9, 10, 13, 14, 15, 12,
  4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11,
  5, 6, 7, 4, 3, 0, 1, 2, 13, 14, 15, 12, 11, 8, 9, 10,
  6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9,
  7, 4, 5, 6, 1, 2, 3, 0, 15, 12, 13, 14, 9, 10, 11, 8,
  8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7,
  9, 10, 11, 8, 15, 12, 13, 14, 1, 2, 3, 0, 7, 4, 5, 6,
  10, 11, 8, 9, 14, 15, 12, 13, 2, 3, 0, 1, 6, 7, 4, 5,
  11, 8, 9, 10, 13, 14, 15, 12, 3, 0, 1, 2, 5, 6, 7, 4,
  12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3,
  13, 14, 15, 12, 11, 8, 9, 10, 5, 6, 7, 4, 3, 0, 1, 2,
  14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1,
  15, 12, 13, 14, 9, 10, 11, 8, 7, 4, 5, 6, 1, 2, 3, 0
];

// udSymmetryInverses[s] gives s'.
var udSymmetryInverses = [0, 3, 2, 1, 4, 5, 6, 7, 8, 11, 10, 9, 12, 13, 14, 15];

// udSymmetryInverse returns the inverse of a UD symmetry.
function udSymmetryInverse(sym) {
  return udSymmetryInverses[sym];
}

// udSymmetryLRFlip returns true if the symmetry includes an LR reflection.
function udSymmetryLRFlip(sym) {
  return (sym & 4) !== 0;
}

// udSymmetryProduct returns the product of two symmetries, s1*s2.
function udSymmetryProduct(s1, s2) {
  return udSymmetryProducts[(s1 << 4) | s2];
}

// udSymmetryUDFlip returns true if the symmetry includes a UD reflection.
function udSymmetryUDFlip(sym) {
  return (sym & 8) !== 0;
}

// udSymmetryY returns the number of y rotations performed by the symmetry.
function udSymmetryY(sym) {
  return sym & 3;
}

exports.udSymmetryInverse = udSymmetryInverse;
exports.udSymmetryLRFlip = udSymmetryLRFlip;
exports.udSymmetryProduct = udSymmetryProduct;
exports.udSymmetryUDFlip = udSymmetryUDFlip;
exports.udSymmetryY = udSymmetryY;