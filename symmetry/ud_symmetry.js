// There are 16 symmetries of the cube which preserve the UD axis. These
// symmetries can be generated by performing cube rotations around the y axis,
// flips across the LR axis, and flips across the UD axis. The LR flip could be
// substituted for an FB flip; I chose LR arbitrarily.
//
// Since there are 16 symmetries, I represent symmetries as 4 bit numbers. The
// lower 2 bits store the number of y rotations. The third bit is set for an LR
// flip, and the fourth bit for a UD flip. If there is a y rotation, an LR flip,
// and a UD flip, the y rotation is performed first, the LR flip second, and the
// UD flip third. So, symmetry 15 represents UDflip*LRflip*y'. It can also be
// noted that the UD flip commutes with the LR flip and the y rotation.

// udSymmetryInverse returns the inverse of a UD symmetry.
function udSymmetryInverse(sym) {
  // If there is an LR flip, the inverse is the same as the original.
  // Also, since UDflip commutes with LRflip and y, it is preserved in the
  // inverse.
  return [0, 3, 2, 1, 4, 5, 6, 7, 8, 11, 10, 9, 12, 13, 14, 15][sym];
}

// udSymmetryLRFlip returns true if the symmetry includes an LR reflection.
function udSymmetryLRFlip(sym) {
  return (sym & 4) !== 0;
}

// udSymmetryProduct returns the product of two symmetries, s1*s2.
function udSymmetryProduct(s1, s2) {
  // Since UDflip commutes, the new UDflip is the xor of the two UDflips.
  var udProduct = (s1 & 8) ^ (s2 & 8);
  
  // The logic below depends on the fact that LRflip*y^n = y^(4-n)*LRflip.
  var lrFlip1 = ((s1 & 4) !== 0);
  var lrFlip2 = ((s2 & 4) !== 0);
  var y1 = (s1 & 3);
  var y2 = (s2 & 3);
  if (!lrFlip1 && !lrFlip2) {
    // This is y^n*y^m = y^(n+m)
    var rotation = (y1 + y2) & 3;
    return udProduct | rotation;
  } else if (!lrFlip1 && lrFlip2) {
    // This is y^n*LRflip*y^m = LRflip*y^(4-n+m)
    var rotation = (4 - y1 + y2) & 3;
    return udProduct | rotation | 4;
  } else if (lrFlip1 && !lrFlip2) {
    // This is LRflip*y^n*y^m = LRflip*y^(n+m)
    var rotation = (y1 + y2) & 3;
    return udProduct | rotation | 4;
  }
  
  // This is LRflip*y^n*LRflip*y^m = y^(4-n)*y^m.
  var rotation = (4 - y1 + y2) & 3;
  return udProduct | rotation;
}

// udSymmetryUDFlip returns true if the symmetry includes a UD reflection.
function udSymmetryUDFlip(sym) {
  return (sym & 8) !== 0;
}

// udSymmetryY returns the number of y rotations performed by the symmetry.
function udSymmetryY(sym) {
  return sym & 3;
}

exports.udSymmetryInverse = udSymmetryInverse;
exports.udSymmetryLRFlip = udSymmetryLRFlip;
exports.udSymmetryProduct = udSymmetryProduct;
exports.udSymmetryUDFlip = udSymmetryUDFlip;
exports.udSymmetryY = udSymmetryY;